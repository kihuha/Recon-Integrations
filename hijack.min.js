"use strict";

(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }

        var p = n[i] = {
          exports: {}
        };
        e[i][0].call(p.exports, function (r) {
          var n = e[i][1][r];
          return o(n || r);
        }, p, p.exports, r, e, n, t);
      }

      return n[i].exports;
    }

    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);

    return o;
  }

  return r;
})()({
  1: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ENABLED_INTEGRATIONS = exports.PROXY_DOMAIN = exports.TOKEN = void 0;
    const TOKEN = '09eb9a73-f998-4c90-b59e-b36071e09212';
    exports.TOKEN = TOKEN;
    const PROXY_DOMAIN = 'daoce2.datocol.com';
    exports.PROXY_DOMAIN = PROXY_DOMAIN;
    const ENABLED_INTEGRATIONS = [{"name":"ga","options":{"custom_dimension":1}},{"name":"gtm"},{"name":"mixpanel"},{"name":"heap"},{"name":"segment"},{"name":"munchkin"},{"name":"facebook-pixel"},{"name":"amplitude"},{"name":"crazyegg"}];
    exports.ENABLED_INTEGRATIONS = ENABLED_INTEGRATIONS;
  }, {}],
  2: [function (require, module, exports) {
    'use strict';

    var _inputs = require("../inputs");

    const name = 'amplitude';

    const isBlocked = function () {
      return new Promise(resolve => {
        const interval = setInterval(function () {
          const amp = window.amplitude;

          if (amp && amp.getInstance() && amp.getInstance().options && amp.getInstance().options.apiKey) {
            fetch('https://api.amplitude.com/2/httpapi', {
              method: 'POST',
              headers: {
                'content-type': 'application/json'
              },
              body: JSON.stringify({
                events: [],
                api_key: window.amplitude.getInstance().options.apiKey
              })
            }).then(async response => {
              if (!response.ok) {
                resolve(true);
              }

              try {
                let parsedResponse = await response.json();
                resolve(parsedResponse['code'] !== 200 || parsedResponse['events_ingested'] !== 0);
              } catch {
                resolve(true);
              }
            })["catch"](_ => resolve(true));
            clearInterval(interval);
          }
        }, 20);
      });
    };

    const isLoaded = function () {
      return !!(window.amplitude && window.amplitude.runQueuedFunctions);
    };

    const labelBlocked = function () {
      const amplitudeIntegration = _inputs.ENABLED_INTEGRATIONS.filter(integration => integration.name === name)[0];

      const instanceNames = amplitudeIntegration.options ? amplitudeIntegration.options.instance_names : undefined;
      const interval = setInterval(function () {
        const amp = window.amplitude;

        if (amp) {
          let markAsBlocked = new amplitude.Identify().set('blocked', 'true');

          if (instanceNames) {
            for (const instanceName of instanceNames) {
              amplitude.getInstance(instanceName).identify(markAsBlocked);
            }
          } else {
            amplitude.getInstance().identify(markAsBlocked);
          }

          clearInterval(interval);
        }
      }, 50);
    };

    const cdnHosts = ['cdn.amplitude.com'];
    const apiHosts = ['api.amplitude.com'];
    const polyfillBuster = undefined;
    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {
    "../inputs": 1
  }],
  3: [function (require, module, exports) {
    'use strict';

    const name = 'crazyegg';

    const isBlocked = async function () {
      try {
        const response = await fetch('https://script.crazyegg.com/pages/scripts/0094/2379.js');
        const responseData = await response.text();

        if (responseData.length > 0 && response.status === 200) {
          return false;
        }

        return true;
      } catch (e) {
        return true;
      }
    };

    const isLoaded = function () {
      return !!(window.CE2 && window.CE2BH);
    };

    const labelBlocked = function () {
      if (window.CE2) {
        CE2.set(1, 'blocked');
      }
    };

    const apiHosts = ['script.crazyegg.com'];
    const cdnHosts = ['script.crazyegg.com'];
    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts
    };
  }, {}],
  4: [function (require, module, exports) {
    'use strict';

    const name = 'facebook-pixel';

    const isBlocked = async function () {
      return fetch("https://www.facebook.com/tr", {
        mode: 'no-cors',
        credentials: 'omit'
      }).then(_ => false)["catch"](_ => true);
    };

    const isLoaded = function () {
      return !!(window.fbq && window.fbq.callMethod);
    };

    const labelBlocked = function () {};

    const apiHosts = ['connect.facebook.net', 'www.facebook.com'];
    const cdnHosts = ['connect.facebook.net'];
    const polyfillBuster = undefined;
    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {}],
  5: [function (require, module, exports) {
    'use strict';

    var _inputs = require("../inputs");

    const name = 'ga';
    const isBlocked = undefined;

    const isLoaded = function () {
      const r = 'GoogleAnalyticsObject';
      return window[window[r]] && window[window[r]].loaded && window[window[r]].getByName && window[window[r]].getByName.toString().replace(/[\n\s;]*/g, '') !== 'function(){returnnull}';
    };

    const labelBlocked = function () {
      const config = _inputs.ENABLED_INTEGRATIONS.filter(config => config.name === name)[0];

      const gaObjectName = window.GoogleAnalyticsObject;

      if (config.options && config.options.custom_dimension && gaObjectName && window[gaObjectName]) {
        const gaObject = window[gaObjectName]; // check if the create command for ga includes a different tracker name. if so, set the custom dim. for that tracker

        let setKey = 'set';

        if (gaObject.q[0][0] === 'create' && typeof gaObject.q[0][2] === 'object' && 'name' in gaObject.q[0][2]) {
          setKey = `${gaObject.q[0][2]['name']}.set`;
        }

        gaObject(setKey, `dimension${config.options.custom_dimension}`, 'true');
        let args = gaObject.q.pop();
        gaObject.q.splice(1, 0, args);
      }
    }; // Google Analytics sometimes makes calls to stats.g.doubleclick to record metrics, so we proxy those when made
    // as API calls.


    const apiHosts = ['www.google-analytics.com', 'stats.g.doubleclick.net'];
    const cdnHosts = ['www.google-analytics.com'];

    const overrideGa = function (windowProperty) {
      let gaValue;
      Object.defineProperty(window, windowProperty, {
        set: function (ga) {
          let isPolyfill = ga.getByName && ga.getByName.toString().replace(/[\n ;]/g, '') === 'function(){returnnull}';

          if (isPolyfill) {
            // pretend that the assignment worked
            return ga;
          } else {
            gaValue = ga;
            return ga;
          }
        },
        get: function () {
          return gaValue;
        }
      });
    };

    const polyfillBuster = function () {
      let googleAnalyticsObjectValue;
      Object.defineProperty(window, 'GoogleAnalyticsObject', {
        set: function (objectName) {
          overrideGa(objectName);
          googleAnalyticsObjectValue = objectName;
          return googleAnalyticsObjectValue;
        },
        get: function () {
          return googleAnalyticsObjectValue;
        }
      });
    };

    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {
    "../inputs": 1
  }],
  6: [function (require, module, exports) {
    'use strict';

    var _inputs = require("../inputs");

    const name = 'gtm';
    const isBlocked = undefined;

    const isLoaded = function () {
      return !!window.google_tag_manager;
    };

    const labelBlocked = function () {
      const config = _inputs.ENABLED_INTEGRATIONS.filter(config => config.name === name)[0];

      if (config.options && config.options.custom_dimension && window.gtag && window.dataLayer) {
        window.gtag('set', `dimension${config.options.custom_dimension}`, 'true');
        let args = window.dataLayer.pop();
        window.dataLayer.splice(1, 0, args);
      }
    };

    const apiHosts = ['www.googletagmanager.com'];
    const cdnHosts = ['www.googletagmanager.com'];
    const polyfillBuster = undefined;
    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {
    "../inputs": 1
  }],
  7: [function (require, module, exports) {
    'use strict';

    const name = 'heap';
    const isBlocked = undefined;

    const isLoaded = function () {
      return window.heap && window.heap.loaded;
    };

    const labelBlocked = function () {
      if (window.heap) {
        window.heap.addUserProperties({
          unblocked: 'true'
        });
      }
    };

    const apiHosts = ['heapanalytics.com'];
    const cdnHosts = ['cdn.heapanalytics.com'];
    const polyfillBuster = undefined;
    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {}],
  8: [function (require, module, exports) {
    'use strict';

    var _ga = _interopRequireDefault(require("./ga"));

    var _gtm = _interopRequireDefault(require("./gtm"));

    var _heap = _interopRequireDefault(require("./heap"));

    var _mixpanel = _interopRequireDefault(require("./mixpanel"));

    var _segment = _interopRequireDefault(require("./segment"));

    var _munchkin = _interopRequireDefault(require("./munchkin"));

    var _facebook_pixel = _interopRequireDefault(require("./facebook_pixel"));

    var _amplitude = _interopRequireDefault(require("./amplitude"));

    var _crazyegg = _interopRequireDefault(require("./crazyegg"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    const nameToConfig = {
      segment: _segment["default"],
      heap: _heap["default"],
      mixpanel: _mixpanel["default"],
      ga: _ga["default"],
      gtm: _gtm["default"],
      munchkin: _munchkin["default"],
      'facebook-pixel': _facebook_pixel["default"],
      amplitude: _amplitude["default"],
      crazyegg: _crazyegg["default"]
    };
    const hostToNames = Object.entries(nameToConfig).reduce((accumulator, entry) => {
      const [name, config] = entry;
      [...config.apiHosts, ...config.cdnHosts].forEach(host => {
        accumulator[host] = [name, ...(accumulator[host] || [])];
      });
      return accumulator;
    }, {});
    module.exports = {
      nameToConfig,
      hostToNames
    };
  }, {
    "./amplitude": 2,
    "./crazyegg": 3,
    "./facebook_pixel": 4,
    "./ga": 5,
    "./gtm": 6,
    "./heap": 7,
    "./mixpanel": 9,
    "./munchkin": 10,
    "./segment": 11
  }],
  9: [function (require, module, exports) {
    'use strict';

    const name = 'mixpanel';

    const isBlocked = async function () {
      try {
        const response = await fetch('https://api-js.mixpanel.com/track/?ip=1');

        if (!response.ok) {
          return true;
        } else {
          const text = await response.text();
          return text !== '0';
        }
      } catch (e) {
        return true;
      }
    };

    const isLoaded = function () {
      return window.mixpanel && window.mixpanel.__loaded;
    };

    const labelBlocked = function () {
      if (window.mixpanel) {
        // label all events
        window.mixpanel.register({
          unblocked: 'true'
        }); // label user (only works if a user is identified)

        window.mixpanel.people.set({
          unblocked: 'true'
        });
      }
    };

    const apiHosts = ['api-js.mixpanel.com'];
    const cdnHosts = ['cdn.mxpnl.com'];
    const polyfillBuster = undefined;
    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {}],
  10: [function (require, module, exports) {
    'use strict';

    const name = 'munchkin';
    const isBlocked = undefined;

    const isLoaded = function () {
      return !!window.Munchkin;
    };

    const labelBlocked = function () {// we can't label marketo from Munchkin, we can only do that from the forms
      // since you need a private API key to associate a lead with a value
    };

    const apiHosts = ['mktoresp.com'];
    const cdnHosts = ['munchkin.marketo.net', 'munchkin-cdn.marketo.net'];

    const polyfillBuster = function () {
      let munchkin;
      Object.defineProperty(window, 'Munchkin', {
        set: function (incoming) {
          const validMunchkin = !!(incoming.init && incoming.init.toString() !== 'function(){}' && incoming.createTrackingCookie && incoming.munchkinFunction);

          if (validMunchkin) {
            munchkin = incoming;
          }

          return incoming;
        },
        get: function () {
          return munchkin;
        }
      });
    };

    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {}],
  11: [function (require, module, exports) {
    'use strict';

    const name = 'segment';

    const isBlocked = async function () {
      return await fetch('https://api.segment.io/v1/t').then(async function (response) {
        return !response.ok || (await response.text()).length === 0;
      })["catch"](() => true);
    };

    const isLoaded = function () {
      return window.analytics && window.analytics.initialized;
    };

    const labelBlocked = function () {
      const interval = setInterval(function () {
        if (isLoaded()) {
          window.analytics.identify(window.analytics.user().id(), {
            unblocked: 'true'
          }, {
            anonymousId: window.analytics.user().anonymousId()
          });
          clearInterval(interval);
        }
      }, 10);
    };

    const apiHosts = ['api.segment.io'];
    const cdnHosts = ['cdn.segment.com'];
    const polyfillBuster = undefined;
    module.exports = {
      name,
      isBlocked,
      isLoaded,
      labelBlocked,
      apiHosts,
      cdnHosts,
      polyfillBuster
    };
  }, {}],
  12: [function (require, module, exports) {
    'use strict';

    var _integrations = _interopRequireDefault(require("../integrations"));

    var _loader_toolbox = require("./loader_toolbox");

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    const startChecks = function (enabledIntegrationNames, proxyDomain, token, hostsToProxy) {
      const enabledIntegrations = enabledIntegrationNames.map(name => _integrations["default"].nameToConfig[name]);
      enabledIntegrations.flatMap(integration => integration.cdnHosts).forEach(host => hostsToProxy.cdn.add(host));
      enabledIntegrations.filter(integration => integration.isBlocked !== undefined).forEach(integration => {
        integration.isBlocked().then(isBlocking => {
          if (isBlocking) {
            integration.apiHosts.forEach(host => hostsToProxy.api.add(host));
          }

          (0, _loader_toolbox.countAndLabelUsers)(proxyDomain, token, integration, isBlocking, 'custom function check');
        });
      });
    };

    module.exports = {
      startChecks
    };
  }, {
    "../integrations": 8,
    "./loader_toolbox": 15
  }],
  13: [function (require, module, exports) {
    'use strict';

    var _uuid = require("uuid");

    var _jsCookie = _interopRequireDefault(require("js-cookie"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    const DXT_COOKIE = '_dxc';

    function getOrSetDxtCookie() {
      let current_cookie = _jsCookie["default"].get(DXT_COOKIE);

      if (current_cookie !== undefined) {
        return current_cookie;
      } else {
        let newId = (0, _uuid.v4)();

        _jsCookie["default"].set(DXT_COOKIE, newId, {
          expires: 365,
          path: '/'
        });

        return newId;
      }
    }

    module.exports = {
      getOrSetDxtCookie
    };
  }, {
    "js-cookie": 20,
    "uuid": 22
  }],
  14: [function (require, module, exports) {
    'use strict';

    var _integrations = _interopRequireDefault(require("../integrations"));

    var _obfuscator = require("@dataline/obfuscator");

    var _loader_toolbox = require("./loader_toolbox");

    var _logging = require("./logging");

    var _inputs = require("../inputs");

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    const urlObfuscator = function (pathAndQuery) {
      return (0, _obfuscator.obfuscatePathAndQuery)(pathAndQuery, {
        v1: 'v1'
      });
    }; // Returns an object containing all the properties in URL except for searchParams.
    // We use this helper because the URL object doesn't handle protocol-less URLs.


    const parseUrl = function (url) {
      let a = document.createElement('a');
      a.href = url;
      let pathname = a.pathname; // .pathname on IE omits the leading forward slash, so we add it if it doesn't already exist

      if (pathname.length === 0 || pathname[0] !== '/') {
        pathname = '/' + pathname;
      }

      return {
        hash: a.hash,
        host: a.host,
        hostname: a.hostname,
        href: a.href,
        origin: a.origin,
        password: a.password,
        pathname: pathname,
        port: a.port,
        protocol: a.protocol,
        search: a.search,
        username: a.username
      };
    };

    const urlMatchesSuffix = function (hostPatternSet, src) {
      let parsedUrl = parseUrl(src);
      return [...hostPatternSet].some(hostPattern => parsedUrl.hostname.endsWith(hostPattern));
    };

    const decorateXhr = function (obfuscateIfNecessary) {
      const open = XMLHttpRequest.prototype.open;

      XMLHttpRequest.prototype.open = function () {
        const asynchronous = arguments.length === 2 || arguments.length > 2 && arguments[2];

        if (asynchronous) {
          const url = arguments[1];
          arguments[1] = obfuscateIfNecessary(url, XMLHttpRequest.prototype.toString(), 'xhr');
          return open.apply(this, arguments);
        } else {
          return open.apply(this, arguments);
        }
      };
    };

    const decorateSrcAttribute = function (prototype, type, obfuscateIfNecessary) {
      Object.defineProperty(prototype, 'src', {
        set: function (src) {
          let newSrc = obfuscateIfNecessary(src, prototype.toString(), type);
          this.setAttribute('src', newSrc);
          return newSrc;
        },
        get: function () {
          return this.getAttribute('src');
        }
      });
    };

    const appendScriptToDom = function (unblockedScriptElement, originalScriptElement) {
      originalScriptElement.parentNode.insertBefore(unblockedScriptElement, originalScriptElement);
    };

    const createScriptElement = function (src, asynchronous) {
      const element = document.createElement('script');
      element.type = 'text/javascript';
      element.async = !!asynchronous;
      element.src = src;
      return element;
    };

    const enabledIntegrationNames = _inputs.ENABLED_INTEGRATIONS.map(config => config.name);

    const blockedCdnHosts = new Set();

    const override = function (proxyDomain, token, hostsToProxy) {
      const captureEventListeners = function () {
        const _super = {
          addEventListener: HTMLScriptElement.prototype.addEventListener,
          removeEventListener: HTMLScriptElement.prototype.removeEventListener
        };

        HTMLScriptElement.prototype['addEventListener'] = function () {
          if (this.src && urlMatchesSuffix(hostsToProxy.cdn, this.src)) {
            this._dxtGetEventListeners().push(arguments);
          } else {
            _super.addEventListener.apply(this, arguments);
          }
        };

        HTMLScriptElement.prototype['removeEventListener'] = function () {
          if (this.src && urlMatchesSuffix(hostsToProxy.cdn, this.src)) {
            const listeners = this._dxtGetEventListeners();

            const idx = listeners.indexOf(arguments);

            if (idx !== -1) {
              listeners.splice(idx);
            }
          } else {
            _super.removeEventListener.apply(this, arguments);
          }
        };

        HTMLScriptElement.prototype['_dxtGetEventListeners'] = function () {
          this._dxtEventListeners = this._dxtEventListeners || [];
          return this._dxtEventListeners;
        };

        HTMLScriptElement.prototype['_dxtRunOnloadEventListeners'] = function () {
          this._dxtGetEventListeners().filter(addEventListenerArgs => addEventListenerArgs[0] === 'load').forEach(arg => {
            // we can safely ignore the remaining args since they aren't related to scripts.
            // See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener for more details
            const handler = arg[1];
            handler.call(this);
          });
        }; // retain the original method so we can attach our event listeners


        HTMLScriptElement.prototype['_protoAddEventListener'] = _super.addEventListener;
        HTMLScriptElement.prototype['_protoRemoveEventListener'] = _super.removeEventListener; // passing in both legacy event name and event name for searchability

        const overrideLegacyStyleListener = function (legacyEventName) {
          if (!legacyEventName.startsWith('on')) {
            (0, _logging.log)(`ERROR: unexpected event name: ${legacyEventName}. Must start with 'on'`);
          }

          const alternativePropertyName = `_dxtproto${legacyEventName}`;
          const eventName = legacyEventName.slice(2);
          Object.defineProperty(HTMLScriptElement.prototype, legacyEventName, {
            set: function (handler) {
              // We currently don't support capturing event handlers for scripts which don't have a src set, so bypass
              // this functionality if this is the case
              if (!this.src || !urlMatchesSuffix(hostsToProxy.cdn, this.src)) {
                // first remove any previously set listener, then add the new one to preserve contract that there can only be
                // 1 legacy event handler fn (1 onload, 1 onerror, etc..). We could set this directly into onload but it'd
                // cause an infinite loop.
                if (this[alternativePropertyName]) {
                  this._protoRemoveEventListener(eventName, this[alternativePropertyName]);
                }

                this._protoAddEventListener(eventName, handler);
              } else {
                // if this is a script we want to proxy, run it through the standard override process defined above
                // There can only be one legacy style event listener (e.g: onload) on an object, so we remove it if it
                // exists
                if (this[alternativePropertyName]) {
                  this.removeEventListener(eventName, this[alternativePropertyName]);
                }

                this.addEventListener(eventName, handler);
              }

              this[alternativePropertyName] = handler;
            },
            get: function () {
              return this[alternativePropertyName];
            }
          });
        };

        overrideLegacyStyleListener('onload');
        overrideLegacyStyleListener('onerror');
        overrideLegacyStyleListener('onreadystatechange');
      };
      /*
      If these are not converted from attributes to event listeners, they would trigger immediately after the script loads,
      not after we successfully fall back on a different script.
       */


      const preserveEventAttributes = function (element) {
        for (let eventAttribute of ['onload', 'onerror', 'onreadystatechange']) {
          if (element.hasAttribute(eventAttribute)) {
            const eventName = eventAttribute.substring(2);
            const onloadValue = element.getAttribute(eventAttribute);
            element.removeAttribute(eventAttribute);
            element.addEventListener(eventName, function () {
              eval(onloadValue);
            });
          }
        }
      };

      const attachOnloadFallbackHandlers = function (element, hostname, initiator, endpoint, src, obfuscatedSrc) {
        preserveEventAttributes(element);
        const relevantIntegrations = new Set(Object.keys(_integrations["default"].hostToNames).flatMap(host => {
          let relevantConfigs = [];

          if (urlMatchesSuffix([host], src)) {
            for (let integrationName of _integrations["default"].hostToNames[host]) {
              if (enabledIntegrationNames.includes(integrationName)) {
                relevantConfigs.push(_integrations["default"].nameToConfig[integrationName]);
              }
            }
          }

          return relevantConfigs;
        }));

        const onblocked = function () {
          relevantIntegrations.forEach(integration => {
            integration.apiHosts.forEach(host => {
              hostsToProxy.api.add(host);
            });
            integration.cdnHosts.forEach(host => {
              blockedCdnHosts.add(host);
            });
            (0, _loader_toolbox.countAndLabelUsers)(proxyDomain, token, integration, true, 'blocked script load');
          });
          (0, _logging.log)(`${initiator}+onerror(${endpoint}):`, src, '=>', obfuscatedSrc);
          const unblockedScriptElement = createScriptElement(obfuscatedSrc, element.async); // for the unblocked script, we just want to attach the original event listeners the way they were previously

          for (const arg of element._dxtGetEventListeners()) {
            unblockedScriptElement._protoAddEventListener.apply(unblockedScriptElement, arg);
          }

          appendScriptToDom(unblockedScriptElement, element);
        };

        element._protoAddEventListener('error', function () {
          onblocked();
        });

        element._protoAddEventListener('load', function () {
          for (let integration of relevantIntegrations) {
            setTimeout(function () {
              if (integration.isLoaded() && !urlMatchesSuffix(blockedCdnHosts, src)) {
                element._dxtRunOnloadEventListeners();

                (0, _loader_toolbox.countAndLabelUsers)(proxyDomain, token, integration, false, 'successful script load');
              } else {
                onblocked('onload waiter ' + integration.name);
              }
            }, 20);
          }
        });
      };

      const obfuscateIfNecessary = function (src, initiator, type) {
        const parsedUrl = parseUrl(src);
        const endpoint = type === 'script' ? 'asset' : 'api';
        const obfuscatedPartialPath = urlObfuscator(`/${endpoint}/${parsedUrl.href}`);
        const obfuscatedSrc = `${parsedUrl.protocol}//${proxyDomain}${obfuscatedPartialPath}`;

        if (urlMatchesSuffix(hostsToProxy.api, src)) {
          (0, _logging.log)(`${initiator}(${endpoint}):`, src, '=>', obfuscatedSrc);
          return obfuscatedSrc;
        } else {
          return src;
        }
      };

      const scriptDecoratorCallback = function (mutationList, observer) {
        mutationList.forEach(mutation => {
          if (mutation.type === 'childList') {
            for (let node of mutation.addedNodes) {
              if (node.tagName === 'SCRIPT' && node.src) {
                let parsedUrl = parseUrl(node.src);
                let endpoint = 'asset';

                if (urlMatchesSuffix(hostsToProxy.cdn, node.src)) {
                  const obfuscatedPartialPath = urlObfuscator(`/${endpoint}/${parsedUrl.href}`);
                  const obfuscatedSrc = `${parsedUrl.protocol}//${proxyDomain}${obfuscatedPartialPath}`;
                  attachOnloadFallbackHandlers(node, parsedUrl.hostname, 'mutation callback', endpoint, node.src, obfuscatedSrc);
                }
              }
            }
          }
        });
      };

      captureEventListeners();
      new MutationObserver(scriptDecoratorCallback).observe(document, {
        childList: true,
        attributes: true,
        subtree: true
      });
      decorateSrcAttribute(HTMLImageElement.prototype, 'img', obfuscateIfNecessary);
      decorateSrcAttribute(Image.prototype, 'img', obfuscateIfNecessary);
      decorateXhr(obfuscateIfNecessary);
    };

    module.exports = {
      override
    };
  }, {
    "../inputs": 1,
    "../integrations": 8,
    "./loader_toolbox": 15,
    "./logging": 16,
    "@dataline/obfuscator": 31
  }],
  15: [function (require, module, exports) {
    'use strict';

    var _cookies = _interopRequireDefault(require("./cookies"));

    var _logging = require("./logging");

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    } // We keep separate sets to account for the case where a single integration is marked as both blocked and unblocked.
    // This can happen in cases where an integration's main script isn't blocked, but one of its sub-scripts is blocked.
    // We still want to mark the user as unblocked to count them towards MTU.


    const countedIntegrations = {
      blocked: new Set(),
      notBlocked: new Set()
    };

    function countAndLabelUsers(proxyDomain, token, integration, isBlocking, cause) {
      const relevantCountedIntegrations = isBlocking ? countedIntegrations.blocked : countedIntegrations.notBlocked;

      if (relevantCountedIntegrations.has(integration.name)) {
        (0, _logging.log)(`countAndLabelUsers(${integration.name}) SKIPPED; ${cause}`);
      } else {
        (0, _logging.log)(`countAndLabelUsers(${integration.name}) = ${isBlocking}; ${cause}`);

        if (isBlocking) {
          integration.labelBlocked();
        }

        relevantCountedIntegrations.add(integration.name);
        const counterUrl = `https://${proxyDomain}/count`;
        const userInfo = {
          _dx_adb: `${isBlocking}`,
          _uid: _cookies["default"].getOrSetDxtCookie(),
          _token: token,
          _integration: integration.name
        };
        fetch(counterUrl, {
          method: 'POST',
          body: JSON.stringify(userInfo)
        })["catch"](e => window.dxtDebugLog(e));
      }
    }

    module.exports.countAndLabelUsers = countAndLabelUsers;
  }, {
    "./cookies": 13,
    "./logging": 16
  }],
  16: [function (require, module, exports) {
    'use strict';

    let log = function () {
      if (window.location.search.includes('dxtDebug')) {
        console.debug.apply(this, arguments);
      }
    };

    module.exports.log = log;
  }, {}],
  17: [function (require, module, exports) {
    'use strict';

    var _integrations = _interopRequireDefault(require("../integrations"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    const start = function (enabledIntegrationNames) {
      enabledIntegrationNames.map(name => _integrations["default"].nameToConfig[name]).filter(integration => integration.polyfillBuster !== undefined).forEach(integration => integration.polyfillBuster());
    };

    module.exports = {
      start
    };
  }, {
    "../integrations": 8
  }],
  18: [function (require, module, exports) {
    'use strict'; // todo: report hosts we see and support but are not enabled, or report all?
    // todo: typescript
    // todo: add a test case for loading our script twice
    // todo: add fetch decorator

    var _decorators = _interopRequireDefault(require("./lib/decorators"));

    var _checks = _interopRequireDefault(require("./lib/checks"));

    var _polyfill_buster = _interopRequireDefault(require("./lib/polyfill_buster"));

    var _inputs = require("./inputs");

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    if (!window.dxt_loaded) {
      window.dxt_loaded = true;

      const enabledIntegrationNames = _inputs.ENABLED_INTEGRATIONS.map(cfg => cfg.name);

      const hostsToProxy = {
        api: new Set(),
        cdn: new Set()
      };

      _polyfill_buster["default"].start(enabledIntegrationNames);

      _checks["default"].startChecks(enabledIntegrationNames, _inputs.PROXY_DOMAIN, _inputs.TOKEN, hostsToProxy);

      _decorators["default"].override(_inputs.PROXY_DOMAIN, _inputs.TOKEN, hostsToProxy);
    }
  }, {
    "./inputs": 1,
    "./lib/checks": 12,
    "./lib/decorators": 14,
    "./lib/polyfill_buster": 17
  }],
  19: [function (require, module, exports) {
    (function (global) {
      /*
       *  base64.js
       *
       *  Licensed under the BSD 3-Clause License.
       *    http://opensource.org/licenses/BSD-3-Clause
       *
       *  References:
       *    http://en.wikipedia.org/wiki/Base64
       */
      ;

      (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(global) : typeof define === 'function' && define.amd ? define(factory) : factory(global);
      })(typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this, function (global) {
        'use strict'; // existing version for noConflict()

        global = global || {};
        var _Base64 = global.Base64;
        var version = "2.5.2"; // if node.js and NOT React Native, we use Buffer

        var buffer;

        if (typeof module !== 'undefined' && module.exports) {
          try {
            buffer = eval("require('buffer').Buffer");
          } catch (err) {
            buffer = undefined;
          }
        } // constants


        var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

        var b64tab = function (bin) {
          var t = {};

          for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;

          return t;
        }(b64chars);

        var fromCharCode = String.fromCharCode; // encoder stuff

        var cb_utob = function (c) {
          if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
          } else {
            var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
            return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
          }
        };

        var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;

        var utob = function (u) {
          return u.replace(re_utob, cb_utob);
        };

        var cb_encode = function (ccc) {
          var padlen = [0, 2, 1][ccc.length % 3],
              ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),
              chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];
          return chars.join('');
        };

        var btoa = global.btoa ? function (b) {
          return global.btoa(b);
        } : function (b) {
          return b.replace(/[\s\S]{1,3}/g, cb_encode);
        };

        var _encode = function (u) {
          var isUint8Array = Object.prototype.toString.call(u) === '[object Uint8Array]';
          return isUint8Array ? u.toString('base64') : btoa(utob(String(u)));
        };

        var encode = function (u, urisafe) {
          return !urisafe ? _encode(u) : _encode(String(u)).replace(/[+\/]/g, function (m0) {
            return m0 == '+' ? '-' : '_';
          }).replace(/=/g, '');
        };

        var encodeURI = function (u) {
          return encode(u, true);
        }; // decoder stuff


        var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;

        var cb_btou = function (cccc) {
          switch (cccc.length) {
            case 4:
              var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
                  offset = cp - 0x10000;
              return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);

            case 3:
              return fromCharCode((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));

            default:
              return fromCharCode((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
          }
        };

        var btou = function (b) {
          return b.replace(re_btou, cb_btou);
        };

        var cb_decode = function (cccc) {
          var len = cccc.length,
              padlen = len % 4,
              n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),
              chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];
          chars.length -= [0, 0, 2, 1][padlen];
          return chars.join('');
        };

        var _atob = global.atob ? function (a) {
          return global.atob(a);
        } : function (a) {
          return a.replace(/\S{1,4}/g, cb_decode);
        };

        var atob = function (a) {
          return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
        };

        var _decode = buffer ? buffer.from && Uint8Array && buffer.from !== Uint8Array.from ? function (a) {
          return (a.constructor === buffer.constructor ? a : buffer.from(a, 'base64')).toString();
        } : function (a) {
          return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString();
        } : function (a) {
          return btou(_atob(a));
        };

        var decode = function (a) {
          return _decode(String(a).replace(/[-_]/g, function (m0) {
            return m0 == '-' ? '+' : '/';
          }).replace(/[^A-Za-z0-9\+\/]/g, ''));
        };

        var noConflict = function () {
          var Base64 = global.Base64;
          global.Base64 = _Base64;
          return Base64;
        }; // export Base64


        global.Base64 = {
          VERSION: version,
          atob: atob,
          btoa: btoa,
          fromBase64: decode,
          toBase64: encode,
          utob: utob,
          encode: encode,
          encodeURI: encodeURI,
          btou: btou,
          decode: decode,
          noConflict: noConflict,
          __buffer__: buffer
        }; // if ES5 is available, make Base64.extendString() available

        if (typeof Object.defineProperty === 'function') {
          var noEnum = function (v) {
            return {
              value: v,
              enumerable: false,
              writable: true,
              configurable: true
            };
          };

          global.Base64.extendString = function () {
            Object.defineProperty(String.prototype, 'fromBase64', noEnum(function () {
              return decode(this);
            }));
            Object.defineProperty(String.prototype, 'toBase64', noEnum(function (urisafe) {
              return encode(this, urisafe);
            }));
            Object.defineProperty(String.prototype, 'toBase64URI', noEnum(function () {
              return encode(this, true);
            }));
          };
        } //
        // export Base64 to the namespace
        //


        if (global['Meteor']) {
          // Meteor.js
          Base64 = global.Base64;
        } // module.exports and AMD are mutually exclusive.
        // module.exports has precedence.


        if (typeof module !== 'undefined' && module.exports) {
          module.exports.Base64 = global.Base64;
        } else if (typeof define === 'function' && define.amd) {
          // AMD. Register as an anonymous module.
          define([], function () {
            return global.Base64;
          });
        } // that's it!


        return {
          Base64: global.Base64
        };
      });
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}],
  20: [function (require, module, exports) {
    /*!
     * JavaScript Cookie v2.2.1
     * https://github.com/js-cookie/js-cookie
     *
     * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
     * Released under the MIT license
     */
    ;

    (function (factory) {
      var registeredInModuleLoader;

      if (typeof define === 'function' && define.amd) {
        define(factory);
        registeredInModuleLoader = true;
      }

      if (typeof exports === 'object') {
        module.exports = factory();
        registeredInModuleLoader = true;
      }

      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();

        api.noConflict = function () {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function () {
      function extend() {
        var i = 0;
        var result = {};

        for (; i < arguments.length; i++) {
          var attributes = arguments[i];

          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }

        return result;
      }

      function decode(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }

      function init(converter) {
        function api() {}

        function set(key, value, attributes) {
          if (typeof document === 'undefined') {
            return;
          }

          attributes = extend({
            path: '/'
          }, api.defaults, attributes);

          if (typeof attributes.expires === 'number') {
            attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
          } // We're using "expires" because "max-age" is not supported by IE


          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

          try {
            var result = JSON.stringify(value);

            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {}

          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = '';

          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }

            stringifiedAttributes += '; ' + attributeName;

            if (attributes[attributeName] === true) {
              continue;
            } // Considers RFC 6265 section 5.2:
            // ...
            // 3.  If the remaining unparsed-attributes contains a %x3B (";")
            //     character:
            // Consume the characters of the unparsed-attributes up to,
            // not including, the first %x3B (";") character.
            // ...


            stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
          }

          return document.cookie = key + '=' + value + stringifiedAttributes;
        }

        function get(key, json) {
          if (typeof document === 'undefined') {
            return;
          }

          var jar = {}; // To prevent the for loop in the first place assign an empty array
          // in case there are no cookies at all.

          var cookies = document.cookie ? document.cookie.split('; ') : [];
          var i = 0;

          for (; i < cookies.length; i++) {
            var parts = cookies[i].split('=');
            var cookie = parts.slice(1).join('=');

            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }

            try {
              var name = decode(parts[0]);
              cookie = (converter.read || converter)(cookie, name) || decode(cookie);

              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {}
              }

              jar[name] = cookie;

              if (key === name) {
                break;
              }
            } catch (e) {}
          }

          return key ? jar[key] : jar;
        }

        api.set = set;

        api.get = function (key) {
          return get(key, false
              /* read as raw */
          );
        };

        api.getJSON = function (key) {
          return get(key, true
              /* read as json */
          );
        };

        api.remove = function (key, attributes) {
          set(key, '', extend(attributes, {
            expires: -1
          }));
        };

        api.defaults = {};
        api.withConverter = init;
        return api;
      }

      return init(function () {});
    });
  }, {}],
  21: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 0x100).toString(16).substr(1);
    }

    function bytesToUuid(buf, offset) {
      var i = offset || 0;
      var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

      return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
    }

    var _default = bytesToUuid;
    exports["default"] = _default;
    module.exports = exports["default"];
  }, {}],
  22: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function () {
        return _v["default"];
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function () {
        return _v2["default"];
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function () {
        return _v3["default"];
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function () {
        return _v4["default"];
      }
    });

    var _v = _interopRequireDefault(require("./v1.js"));

    var _v2 = _interopRequireDefault(require("./v3.js"));

    var _v3 = _interopRequireDefault(require("./v4.js"));

    var _v4 = _interopRequireDefault(require("./v5.js"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  }, {
    "./v1.js": 26,
    "./v3.js": 27,
    "./v4.js": 29,
    "./v5.js": 30
  }],
  23: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    /*
     * Browser-compatible JavaScript MD5
     *
     * Modification of JavaScript MD5
     * https://github.com/blueimp/JavaScript-MD5
     *
     * Copyright 2011, Sebastian Tschan
     * https://blueimp.net
     *
     * Licensed under the MIT license:
     * https://opensource.org/licenses/MIT
     *
     * Based on
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */

    function md5(bytes) {
      if (typeof bytes == 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = new Array(msg.length);

        for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
      }

      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    /*
     * Convert an array of little-endian words to an array of bytes
     */


    function md5ToHexEncodedArray(input) {
      var i;
      var x;
      var output = [];
      var length32 = input.length * 32;
      var hexTab = '0123456789abcdef';
      var hex;

      for (i = 0; i < length32; i += 8) {
        x = input[i >> 5] >>> i % 32 & 0xff;
        hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
      }

      return output;
    }
    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */


    function wordsToMd5(x, len) {
      /* append padding */
      x[len >> 5] |= 0x80 << len % 32;
      x[(len + 64 >>> 9 << 4) + 14] = len;
      var i;
      var olda;
      var oldb;
      var oldc;
      var oldd;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;

      for (i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }

      return [a, b, c, d];
    }
    /*
     * Convert an array bytes to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */


    function bytesToWords(input) {
      var i;
      var output = [];
      output[(input.length >> 2) - 1] = undefined;

      for (i = 0; i < output.length; i += 1) {
        output[i] = 0;
      }

      var length8 = input.length * 8;

      for (i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
      }

      return output;
    }
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */


    function safeAdd(x, y) {
      var lsw = (x & 0xffff) + (y & 0xffff);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 0xffff;
    }
    /*
     * Bitwise rotate a 32-bit number to the left.
     */


    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    /*
     * These functions implement the four basic operations the algorithm uses.
     */


    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }

    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }

    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }

    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }

    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }

    var _default = md5;
    exports["default"] = _default;
    module.exports = exports["default"];
  }, {}],
  24: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = rng; // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.

    var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
    var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

    function rng() {
      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }

      return getRandomValues(rnds8);
    }

    module.exports = exports["default"];
  }, {}],
  25: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0; // Adapted from Chris Veness' SHA1 code at
    // http://www.movable-type.co.uk/scripts/sha1.html

    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;

        case 1:
          return x ^ y ^ z;

        case 2:
          return x & y ^ x & z ^ y & z;

        case 3:
          return x ^ y ^ z;
      }
    }

    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }

    function sha1(bytes) {
      var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
      var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

      if (typeof bytes == 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = new Array(msg.length);

        for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
      }

      bytes.push(0x80);
      var l = bytes.length / 4 + 2;
      var N = Math.ceil(l / 16);
      var M = new Array(N);

      for (var i = 0; i < N; i++) {
        M[i] = new Array(16);

        for (var j = 0; j < 16; j++) {
          M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
      }

      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

      for (var i = 0; i < N; i++) {
        var W = new Array(80);

        for (var t = 0; t < 16; t++) W[t] = M[i][t];

        for (var t = 16; t < 80; t++) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }

        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];

        for (var t = 0; t < 80; t++) {
          var s = Math.floor(t / 20);
          var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }

        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }

      return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
    }

    var _default = sha1;
    exports["default"] = _default;
    module.exports = exports["default"];
  }, {}],
  26: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _rng = _interopRequireDefault(require("./rng.js"));

    var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    } // **`v1()` - Generate time-based UUID**
    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html


    var _nodeId;

    var _clockseq; // Previous uuid creation time


    var _lastMSecs = 0;
    var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189

      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || _rng["default"])();

        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }

        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


      var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock

      var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval


      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      } // Per 4.2.1.2 Throw error if too many uuids are requested


      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }

      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

      msecs += 12219292800000; // `time_low`

      var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff; // `time_mid`

      var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff; // `time_high_and_version`

      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

      b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

      b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

      b[i++] = clockseq & 0xff; // `node`

      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }

      return buf ? buf : (0, _bytesToUuid["default"])(b);
    }

    var _default = v1;
    exports["default"] = _default;
    module.exports = exports["default"];
  }, {
    "./bytesToUuid.js": 21,
    "./rng.js": 24
  }],
  27: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _v = _interopRequireDefault(require("./v35.js"));

    var _md = _interopRequireDefault(require("./md5.js"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    const v3 = (0, _v["default"])('v3', 0x30, _md["default"]);
    var _default = v3;
    exports["default"] = _default;
    module.exports = exports["default"];
  }, {
    "./md5.js": 23,
    "./v35.js": 28
  }],
  28: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;
    exports.URL = exports.DNS = void 0;

    var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    function uuidToBytes(uuid) {
      // Note: We assume we're being passed a valid uuid string
      var bytes = [];
      uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
        bytes.push(parseInt(hex, 16));
      });
      return bytes;
    }

    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str)); // UTF8 escape

      var bytes = new Array(str.length);

      for (var i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
      }

      return bytes;
    }

    const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    exports.DNS = DNS;
    const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    exports.URL = URL;

    function _default(name, version, hashfunc) {
      var generateUUID = function (value, namespace, buf, offset) {
        var off = buf && offset || 0;
        if (typeof value == 'string') value = stringToBytes(value);
        if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
        if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
        if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3

        var bytes = hashfunc(namespace.concat(value));
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;

        if (buf) {
          for (var idx = 0; idx < 16; ++idx) {
            buf[off + idx] = bytes[idx];
          }
        }

        return buf || (0, _bytesToUuid["default"])(bytes);
      }; // Function#name is not settable on some platforms (#270)


      try {
        generateUUID.name = name;
      } catch (err) {} // For CommonJS default export support


      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
  }, {
    "./bytesToUuid.js": 21
  }],
  29: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _rng = _interopRequireDefault(require("./rng.js"));

    var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    function v4(options, buf, offset) {
      var i = buf && offset || 0;

      if (typeof options == 'string') {
        buf = options === 'binary' ? new Array(16) : null;
        options = null;
      }

      options = options || {};

      var rnds = options.random || (options.rng || _rng["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }

      return buf || (0, _bytesToUuid["default"])(rnds);
    }

    var _default = v4;
    exports["default"] = _default;
    module.exports = exports["default"];
  }, {
    "./bytesToUuid.js": 21,
    "./rng.js": 24
  }],
  30: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _v = _interopRequireDefault(require("./v35.js"));

    var _sha = _interopRequireDefault(require("./sha1.js"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    const v5 = (0, _v["default"])('v5', 0x50, _sha["default"]);
    var _default = v5;
    exports["default"] = _default;
    module.exports = exports["default"];
  }, {
    "./sha1.js": 25,
    "./v35.js": 28
  }],
  31: [function (require, module, exports) {
    const {
      obfuscate,
      deobfuscate
    } = require('./v1');

    const V1_PATH_PREFIX = '/v1/';
    const V1_BODY_PREFIX = 'v1-';

    function randomizePath(data) {
      let splits = [0];

      for (let i = 2; i < data.length; ++i) {
        if (Math.floor(Math.random() * 10) === 0) {
          splits.push(i);
          i += 2; // ensure sensible path component size
        }
      }

      splits.push(data.length);
      let dataSplits = [];

      for (let i = 1; i < splits.length; ++i) {
        dataSplits.push(data.slice(splits[i - 1], splits[i]));
      }

      return dataSplits.join('/');
    }

    function obfuscatePathAndQuery(data, options) {
      if (!options) {
        throw new Error('Missing option');
      }

      if (options.hasOwnProperty('v1')) {
        return V1_PATH_PREFIX + randomizePath(obfuscate(data, options['v1']));
      }

      throw new Error('Unknown version');
    }

    function deobfuscatePathAndQuery(odata) {
      if (odata.startsWith(V1_PATH_PREFIX)) {
        return deobfuscate(odata.substr(V1_PATH_PREFIX.length).replace(/\//g, ''));
      }

      throw new Error('Unknown version');
    }

    function obfuscateBody(data, options) {
      if (!options) {
        throw new Error('Missing option');
      }

      if (options.hasOwnProperty('v1')) {
        return V1_BODY_PREFIX + obfuscate(data, options['v1']);
      }

      throw new Error('Unknown version');
    }

    function deobfuscateBody(odata) {
      if (odata.startsWith(V1_BODY_PREFIX)) {
        return deobfuscate(odata.substr(V1_BODY_PREFIX.length));
      }

      throw new Error('Unknown version');
    }

    module.exports = {
      obfuscatePathAndQuery,
      deobfuscatePathAndQuery,
      obfuscateBody,
      deobfuscateBody
    };
  }, {
    "./v1": 32
  }],
  32: [function (require, module, exports) {
    const Base64 = require('js-base64').Base64;

    function obfuscate(data) {
      return Base64.encode(data).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }

    function deobfuscate(odata) {
      return Base64.decode(odata);
    }

    module.exports = {
      obfuscate,
      deobfuscate
    };
  }, {
    "js-base64": 19
  }]
}, {}, [18]);